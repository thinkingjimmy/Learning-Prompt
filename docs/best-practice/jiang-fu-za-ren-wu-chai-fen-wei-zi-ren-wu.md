# 🧩 将复杂任务拆分为子任务

正如在软件工程中将一个复杂系统分解为一组模块化组件是一种很好的做法一样，这对于提交给 GPT 的任务也同样适用。复杂任务往往比简单任务具有更高的错误率。此外，复杂任务通常可以被重新定义为由一系列简单任务组成的工作流程，其中前面任务的输出用于构建后续任务的输入。

## 利用意图分类来确定用户查询最相关的指示

对于那些需要大量独立指令集来处理不同情况的任务，首先对查询类型进行分类，并利用该分类来确定所需的指令可能会有所帮助。这可以通过定义固定的类别和硬编码处理给定类别任务所需的相关指令来实现。这个过程也可以递归应用，将一个任务分解为一系列的阶段。这种方法的优点在于，每个查询只包含执行任务下一阶段所需的指令，与使用单一查询来执行整个任务相比，可以降低错误率。这也可能降低成本，因为更大的提示运行起来更加昂贵。

例如，假设对于一个客户服务应用，查询可以有用地分类如下：

提示语：

<pre data-overflow="wrap"><code><strong>你将收到客户服务咨询。请将每个咨询划分为主要类别和次要类别，并以JSON格式提供输出，键名为：主要类别和次要类别。
</strong>
主要类别：账单、技术支持、账户管理或一般咨询。

账单次要类别：
- 退订或升级
- 添加付款方式
- 收费说明
- 争议收费

技术支持次要类别：
- 故障排查
- 设备兼容性
- 软件更新

账户管理次要类别：
- 重置密码
- 更新个人信息
- 注销账户
- 账户安全

一般咨询次要类别：
- 产品信息
- 价格
- 反馈
- 与人工客服沟通

客户：我需要恢复我的网络连接。
</code></pre>

小语 4.0 回复：

```
{
  "主要类别": "技术支持",
  "次要类别": "故障排查"
}
```

<figure><img src="../.gitbook/assets/image(18).png" alt="" /><figcaption></figcaption></figure>

根据客户咨询的分类，我们可以为GPT模型提供一套更具体的指示来处理后续步骤。例如，假设客户需要帮助进行"故障排查"。

提示语：

{% code overflow="wrap" %}
```
你将会收到需要进行技术支持故障排查的客户服务咨询。你可以通过以下方式帮助用户：

- 建议他们检查路由器的所有线缆是否已连接。请注意，线缆随着时间的推移容易松动。
- 如果所有线缆都已连接，但问题仍然存在，请询问他们使用的路由器型号。
- 现在，您将指导他们如何重启设备：
-- 如果型号为MTD-327J，请建议他们按住红色按钮5秒钟，然后等待5分钟后再测试连接。
-- 如果型号为MTD-327S，请建议他们将其拔下并重新插入，然后等待5分钟后再测试连接。
- 如果客户在重启设备并等待5分钟后问题仍然存在，请将他们连接到IT支持部门，输出{"IT support requested"}。
- 如果用户开始询问与此主题无关的问题，那么请确认他们是否希望结束当前关于故障排查的聊天，并根据以下方案对他们的请求进行分类：

将他们的查询分为主要类别和次要类别。请以json格式提供您的输出，键为：主要类别和次要类别。

主要类别：账单、技术支持、账户管理或一般咨询。

账单次要类别：
- 退订或升级
- 添加支付方式
- 收费说明
- 争议收费

技术支持次要类别：
- 故障排查
- 设备兼容性
- 软件更新

账户管理次要类别：
- 重置密码
- 更新个人信息
- 关闭账户
- 账户安全

一般咨询次要类别：
- 产品信息
- 定价
- 反馈
- 与人交谈

客户：我需要让我的互联网重新工作起来。
```
{% endcode %}

小语 4.0 回复：

{% code overflow="wrap" %}
```
您好！请先检查一下路由器的所有线缆是否已连接好。有时候线缆可能会随着时间的推移而松动。如果线缆都已连接好，但问题仍然存在，请告诉我您使用的路由器型号，我将为您提供进一步的帮助。
```
{% endcode %}

<figure><img src="../.gitbook/assets/image(87).png" alt="" /><figcaption></figcaption></figure>

请注意，这个模型就像一个游戏，它可以发出特殊的文字来告诉我们游戏进行到哪一步了。这样我们就可以把这个系统想象成一个游戏机，游戏机里的每一步都决定了我们应该做什么。通过记住每一步，了解在这一步我们可以做什么，以及下一步我们可以做什么，我们就可以更好地保护用户的体验，这在一些不太有规则的方法中是很难做到的。

{% hint style="warning" %}
如果我们不是开发者的话，下面的两个技巧我们都用不到。我们这里也只是简单介绍，如需深入学习可前往[OpenAI 官方文档](https://platform.openai.com/docs/guides/gpt-best-practices/tactic-summarize-long-documents-piecewise-and-construct-a-full-summary-recursively)进行查看。
{% endhint %}

## **对需要非常多内容的对话场景，可以对之前的对话进行总结或过滤**

由于GPT具有固定的上下文长度，用户和GPT之间的对话如果包含了整个对话内容，那么对话就无法无限制地进行下去。解决此问题有多种方法，其中之一是总结前面的对话内容。并将先前对话的摘要包含在下一次的提问中。

一个简化的举例说明：

假设你与GPT在对话中讨论了气候变化、可再生能源和碳排放。你现在想问GPT关于这些主题的更深入的问题，但是你不能把所有的对话都包含在输入中。这时你可以对前置对话进行总结，并在下一次提问中进行输入，比如："<mark style="color:blue;">**在前面的对话中，我们讨论了气候变化的影响，探讨了各种可再生能源的优点和缺点，以及碳排放的环境影响**</mark><mark style="color:blue;">。</mark><mark style="color:red;">**关于这个主题，我想知道如何有效地降低碳排放**</mark><mark style="color:blue;">。</mark>"在这个例子中，<mark style="color:blue;">**标蓝部分**</mark>就是对前置对话的总结，他的作用是帮助GPT在超长的对话中，更好的理解上下文。<mark style="color:red;">**标红部分**</mark>则是你基于这个总结提出的，需要GPT继续回答分析的新问题。

## **逐段总结长篇文档并递归构建完整总结**

由于GPT具有固定的上下文长度，因此无法在单个查询中对长度超过上下文长度减去生成摘要长度的文本进行总结。

要总结一本非常长的文档，如一本书，我们可以使用一系列查询来逐个总结文档的每个部分。各部分的摘要可以合并并进行总结，从而生成摘要的摘要。这个过程可以递归进行，直到整个文档被总结。如果需要使用关于前面部分的信息来理解后面部分，那么在总结某一点的内容时，包含文本前面部分的运行摘要会是一个有用的技巧。OpenAI在之前的研究中使用GPT-3的变体研究了这种程序总结书籍的有效性。

一个简化的举例说明：

假设我们有一本非常长的书，我们想要使用GPT来生成这本书的总结。由于这本书的长度超过了GPT的上下文长度，我们不能一次性把整本书作为输入给GPT。这时，我们可以采取这样的策略：

1. 首先，我们可以把书分成几个部分，比如按章节分。对于每一章，我们都生成一个总结。例如，对于第一章，我们可以给GPT一个提示，比如："请总结以下的文本，这是一本书的第一章..."，然后附上第一章的内容。
2. 当我们有了所有章节的总结后，我们可以将这些总结连接起来，然后再生成一个总的总结。这个总的总结就是对整本书的总结。为了生成这个总结，我们可以给GPT一个新的提示，比如："请总结以下的文本，这是关于一本书各章节的总结..."，然后附上所有章节的总结。
3. 在这个过程中，如果我们发现有些部分的内容需要对前面的内容有一些理解才能够理解，我们可以在总结这一部分的时候，附上前面内容的总结。这就是所谓的「**运行总结**」。这样，GPT就可以在理解后面的内容时，参考前面的总结。

> **如果你对"运行总结"的概念还不是很理解，那可以看一下这个例子：**
>
> 假设我们已经对前两章进行了总结，并且我们正在处理第三章。但是，为了理解第三章的内容，我们需要对前两章的内容有一定的理解。也就是说，第三章的内容与前两章的内容有所关联。在这种情况下，如果我们只是单独地对第三章进行总结，那么我们可能会丢失一些重要的上下文信息。这时我们可以给GPT一个这样的输入：**"以下是关于这本书前两章的总结...（这里是前两章的总结）。现在，请总结以下的文本，这是第三章的内容..."，然后附上第三章的内容。这样，GPT就可以在理解第三章的内容时，参考前两章的总结。**这就是"运行总结"的概念。它可以帮助我们处理一些需要对前面的内容有一定理解才能理解的情况。



